<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>圓錐曲線 3D 精確解析教具</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        *, *::before, *::after { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background: #050505; font-family: system-ui, sans-serif; color: #eee; }
        
        /* 全域標題 */
        .main-title {
            position: absolute; top: 18px; left: 18px; z-index: 100;
            font-size: 1.5em; font-weight: bold; color: #00ffcc;
            text-shadow: 0 0 10px rgba(0,255,204,0.5); pointer-events: none;
        }

        /* --- [電腦版佈局：原封不動] --- */
        #ui { 
            position: absolute; top: 0; left: 0; bottom: 0;
            background: rgba(15, 15, 15, 0.98); padding: 75px 12px 12px 12px; 
            width: 210px; border-right: 1px solid #444; 
            z-index: 10; overflow-y: auto; 
        }
        .section-title {
            font-size: 0.85em; color: #888; margin-bottom: 12px;
            border-left: 2px solid #00ffcc; padding-left: 8px; font-weight: bold;
        }
        .type-label { 
            font-size: 1.2em; color: #00ffcc; text-align: center; 
            font-weight: bold; padding: 6px; border-bottom: 1px solid #333; 
            margin-bottom: 8px; background: rgba(0,0,0,0.3);
        }
        .param-group { margin-bottom: 12px; border-bottom: 1px solid #333; padding-bottom: 8px; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        label { font-size: 11px; color: #999; }
        input[type=number] { 
            width: 55px; background: #222; border: 1px solid #555; 
            color: #00ffcc; border-radius: 3px; padding: 2px; font-size: 11px;
        }
        input[type=range] { width: 100%; margin: 5px 0; cursor: pointer; }

        #company-logo {
            position: absolute; bottom: 15px; left: 15px;
            width: 70px; height: auto; z-index: 20;
            pointer-events: none;
        }

        #preview-box { 
            position: absolute; bottom: 20px; right: 20px; 
            background: rgba(0,0,0,0.92); padding: 10px; 
            border-radius: 8px; border: 1px solid #555; z-index: 5;
            display: flex; flex-direction: column;
        }

        /* --- [手機版佈局：65/35 空間優化] --- */
        @media (max-width: 768px) {
            .main-title { left: 15px; top: 15px; font-size: 1.4em; }

            canvas { height: 65vh !important; }

            #company-logo {
                top: 15px; right: 15px; bottom: auto; left: auto;
                width: 38px; opacity: 0.9; z-index: 100;
            }

            #ui {
                top: 65vh; left: 0; width: 60%; height: 35vh;
                background: #000; border-right: 1px solid #333; border-top: 1px solid #333;
                padding: 12px 10px 40px 10px;
                border-radius: 0; overflow-y: auto; overflow-x: hidden;
            }

            #preview-box {
                top: 65vh; right: 0; left: auto; 
                width: 40%; height: 35vh;
                background: #050505; border: none; border-top: 1px solid #333; border-left: 1px solid #333;
                padding: 0; justify-content: flex-start; align-items: stretch;
                border-radius: 0;
            }
            .type-label { font-size: 1.1em; padding: 6px; margin-bottom: 0; background: #111; }
            #preview-container { 
                flex: 1; display: flex; flex-direction: column; 
                justify-content: center; align-items: center; padding: 5px;
            }
            #pCanvas { width: 95% !important; height: auto !important; max-width: 110px; }

            /* 手機版禁止滑桿的預設點擊與寬鬆滑動 */
            input[type=range] { pointer-events: none; } /* 用 JS 手動控制 */
        }
    </style>
</head>
<body>

<div class="main-title">圓錐曲線模型</div>

<div id="ui">
    <div class="section-title">數據設定</div>

    <div class="param-group">
        <div class="label-row"><label>母線夾角 (α):</label><input type="number" id="alphaN" value="30"></div>
        <div class="slider-wrapper"><input type="range" id="alphaS" min="5" max="85" step="0.1" value="30"></div>
    </div>

    <div class="param-group">
        <div class="label-row"><label>平面夾角 (β):</label><input type="number" id="betaN" value="90"></div>
        <div class="slider-wrapper"><input type="range" id="betaS" min="0" max="180" step="0.1" value="90"></div>
    </div>

    <div class="param-group">
        <div class="label-row"><label>垂直位移 (Y):</label><input type="number" id="yN" value="2.0"></div>
        <div class="slider-wrapper"><input type="range" id="yS" min="-10" max="10" step="0.1" value="2.0"></div>
    </div>

    <div class="param-group">
        <div class="label-row"><label>水平位移 (X):</label><input type="number" id="xN" value="0.0"></div>
        <div class="slider-wrapper"><input type="range" id="xS" min="-10" max="10" step="0.1" value="0.0"></div>
    </div>

    <div class="param-group">
        <div class="label-row"><label>前後位移 (Z):</label><input type="number" id="zN" value="0.0"></div>
        <div class="slider-wrapper"><input type="range" id="zS" min="-10" max="10" step="0.1" value="0.0"></div>
    </div>
</div>

<img id="company-logo" src="company-logo.png" alt="Company Logo">

<div id="preview-box">
    <div class="type-label" id="curveType">圓</div>
    <div id="preview-container">
        <div style="font-size: 10px; margin-bottom:4px; text-align:center; color:#999;">截面圖形</div>
        <canvas id="pCanvas" width="220" height="220"></canvas>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    // --- 3D 環境建置 ---
    const scene = new THREE.Scene();
    const isMobile = window.innerWidth <= 768;
    const aspect = isMobile ? (window.innerWidth / (window.innerHeight * 0.65)) : ((window.innerWidth - 210) / window.innerHeight);
    const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.GridHelper(30, 60, 0x222222, 0x222222));

    let topCone, bottomCone;
    const coneMat = new THREE.MeshPhongMaterial({ color: 0x3498db, transparent: true, opacity: 0.35, side: THREE.DoubleSide });
    const planeGroup = new THREE.Group();
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(35,35), new THREE.MeshPhongMaterial({color:0xff4757, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
    plane.rotation.x = Math.PI/2;
    planeGroup.add(plane);
    scene.add(planeGroup);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);

    // 初始視距回歸 (32)
    if (isMobile) { camera.position.set(32, 22, 32); } 
    else { camera.position.set(25, 18, 25); }
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);

    const params = ['alpha', 'beta', 'x', 'y', 'z'];
    
    function update() {
        const a = parseFloat(document.getElementById('alphaN').value);
        const b = parseFloat(document.getElementById('betaN').value);
        const px = parseFloat(document.getElementById('xN').value);
        const py = parseFloat(document.getElementById('yN').value);
        const pz = parseFloat(document.getElementById('zN').value);

        if (topCone) { scene.remove(topCone); scene.remove(bottomCone); }
        const radA = a * Math.PI/180;
        const h = 12; 
        const geom = new THREE.ConeGeometry(h*Math.tan(radA), h, 128, 1, true);
        geom.translate(0, -h/2, 0); 
        topCone = new THREE.Mesh(geom, coneMat);
        bottomCone = new THREE.Mesh(geom, coneMat); bottomCone.rotation.x = Math.PI;
        scene.add(topCone, bottomCone);

        const radB_rot = (90 - b) * (Math.PI/180);
        planeGroup.rotation.x = radB_rot;
        planeGroup.position.set(px, py, pz);

        const eb = b > 90 ? 180 - b : b;
        const nx = 0, ny = Math.cos(radB_rot), nz = Math.sin(radB_rot);
        const dist = Math.abs(px*0 + py*ny + pz*nz); 
        const passV = dist < 0.08;
        const tol = 0.1;

        let type = "";
        if (passV) {
            if (Math.abs(eb - a) < tol) type = "一條直線";
            else if (eb > a) type = "一個點";
            else type = "兩相交直線";
        } else {
            if (Math.abs(eb - 90) < tol) type = "圓";
            else if (eb > a) type = "橢圓";
            else if (Math.abs(eb - a) < tol) type = "拋物線";
            else type = "雙曲線";
        }
        document.getElementById('curveType').innerText = type;
        draw2D(type, a, eb, dist);
    }

    function draw2D(type, aDeg, bDeg, dist) {
        const canvas = document.getElementById('pCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,220,220);
        ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 3.5; ctx.fillStyle = "#00ffcc";
        const mid = 110, scale = 25;
        const alpha = aDeg * Math.PI/180, beta = bDeg * Math.PI/180;
        if (type === "圓") {
            ctx.beginPath(); ctx.arc(mid, mid, Math.abs(dist * Math.tan(alpha) * scale), 0, Math.PI*2); ctx.stroke();
        } else if (type === "一個點") {
            ctx.beginPath(); ctx.arc(mid, mid, 6, 0, Math.PI*2); ctx.fill();
        } else if (type === "一條直線") {
            ctx.beginPath(); ctx.moveTo(mid, 20); ctx.lineTo(mid, 200); ctx.stroke();
        } else if (type === "兩相交直線") {
            ctx.beginPath(); const s = Math.tan(alpha);
            ctx.moveTo(mid-100, mid-100*s); ctx.lineTo(mid+100, mid+100*s);
            ctx.moveTo(mid+100, mid-100*s); ctx.lineTo(mid-100, mid+100*s);
            ctx.stroke();
        } else if (type === "橢圓") {
            ctx.beginPath();
            const e = Math.cos(beta) / Math.cos(alpha);
            const a = Math.abs(dist * Math.sin(alpha)*Math.cos(alpha) / (Math.pow(Math.sin(beta),2) - Math.pow(Math.sin(alpha),2)));
            const b = a * Math.sqrt(Math.abs(1 - e*e));
            ctx.ellipse(mid, mid, a*scale, b*scale, 0, 0, Math.PI*2); ctx.stroke();
        } else if (type === "拋物線") {
            ctx.beginPath(); const p = Math.abs(dist * Math.sin(alpha));
            for(let y = -95; y <= 95; y++) {
                const x = (y*y) / (4 * p * scale || 1);
                if(y === -95) ctx.moveTo(mid + x, mid + y); else ctx.lineTo(mid + x, mid + y);
            }
            ctx.stroke();
        } else if (type === "雙曲線") {
            const drawBranch = (s) => {
                ctx.beginPath(); let first = true;
                const e = Math.cos(beta) / Math.cos(alpha);
                const a = Math.abs(dist * Math.cos(alpha)*Math.sin(alpha) / (Math.pow(Math.sin(alpha),2) - Math.pow(Math.sin(beta),2)));
                const b = a * Math.sqrt(Math.abs(e*e - 1));
                for(let y = -95; y <= 95; y++) {
                    const x = a * Math.sqrt(1 + Math.pow(y / (b * scale || 1), 2));
                    if(first) { ctx.moveTo(mid + s * x * scale, mid + y); first = false; }
                    else { ctx.lineTo(mid + s * x * scale, mid + y); }
                }
                ctx.stroke();
            };
            drawBranch(1); drawBranch(-1);
        }
    }

    // --- [核心：依照您的建議重寫觸控邏輯] ---
    params.forEach(p => {
        const s = document.getElementById(p + 'S'), n = document.getElementById(p + 'N');
        const container = s.parentElement; // slider-wrapper

        let startX, startY, isSliding = false;

        // 僅對手機版執行手動攔截
        if (isMobile) {
            container.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSliding = false;
                s.style.pointerEvents = "auto"; // 恢復點擊權限
            }, { passive: true });

            container.addEventListener('touchmove', (e) => {
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;

                // 如果還沒判定方向
                if (!isSliding) {
                    // 左右位移明顯大於上下，才判定為「拉數據」
                    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 10) {
                        isSliding = true;
                    } 
                }

                if (isSliding) {
                    if (e.cancelable) e.preventDefault(); // 阻止捲頁
                    // 手動計算滑桿應有的數值
                    const rect = s.getBoundingClientRect();
                    const percent = Math.min(Math.max((e.touches[0].clientX - rect.left) / rect.width, 0), 1);
                    const val = parseFloat(s.min) + percent * (parseFloat(s.max) - parseFloat(s.min));
                    s.value = val;
                    n.value = Math.round(val * 10) / 10;
                    update();
                }
            }, { passive: false });

            container.addEventListener('touchend', () => {
                s.style.pointerEvents = "none"; // 結束後禁用點擊，防誤觸
            });
        }

        // 電腦版維持正常運作
        s.addEventListener('input', () => { if (!isMobile) { n.value = s.value; update(); } });
        n.addEventListener('change', () => { s.value = n.value; update(); });
    });

    window.addEventListener('resize', () => {
        const isMob = window.innerWidth <= 768;
        const newAspect = isMob ? (window.innerWidth / (window.innerHeight * 0.65)) : ((window.innerWidth - 210) / window.innerHeight);
        camera.aspect = newAspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    update(); animate();
</script>
</body>
</html>
