<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>åœ“éŒæ›²ç·š 3D ç²¾ç¢ºè§£ææ•™å…·</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        *, *::before, *::after { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background: #050505; font-family: system-ui, sans-serif; color: #eee; }
        
        /* å…¨åŸŸæ¨™é¡Œæ¨£å¼ */
        .main-title {
            position: absolute; top: 18px; left: 18px; z-index: 100;
            font-size: 1.5em; font-weight: bold; color: #00ffcc;
            text-shadow: 0 0 10px rgba(0,255,204,0.5); pointer-events: none;
        }

        /* --- [1. é›»è…¦ç‰ˆä½ˆå±€] --- */
        #ui { 
            position: absolute; top: 0; left: 0; bottom: 0;
            background: rgba(15, 15, 15, 0.98); padding: 75px 12px 12px 12px; 
            width: 210px; border-right: 1px solid #444; 
            z-index: 10; overflow-y: auto; 
        }
        .section-title {
            font-size: 0.85em; color: #888; margin-bottom: 12px;
            border-left: 2px solid #00ffcc; padding-left: 8px; font-weight: bold;
        }
        .type-label { 
            font-size: 1.2em; color: #00ffcc; text-align: center; 
            font-weight: bold; padding: 6px; border-bottom: 1px solid #333; 
            margin-bottom: 8px; background: rgba(0,0,0,0.3);
        }
        .param-group { margin-bottom: 12px; border-bottom: 1px solid #333; padding-bottom: 8px; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        label { font-size: 11px; color: #999; }
        input[type=number] { 
            width: 55px; background: #222; border: 1px solid #555; 
            color: #00ffcc; border-radius: 3px; padding: 2px; font-size: 11px;
        }
        input[type=range] { width: 100%; margin: 5px 0; cursor: pointer; }

        #company-logo {
            position: absolute; bottom: 15px; left: 15px;
            width: 70px; height: auto; z-index: 20; pointer-events: none;
        }

        #preview-box { 
            position: absolute; bottom: 20px; right: 20px; 
            background: rgba(0,0,0,0.92); padding: 10px; 
            border-radius: 8px; border: 1px solid #555; z-index: 5;
            display: flex; flex-direction: column;
        }

        /* --- [2. ğŸ“± æ‰‹æ©Ÿç‰ˆä½ˆå±€ (65/35)] --- */
        @media (max-width: 768px) {
            .main-title { left: 15px; top: 15px; font-size: 1.4em; }

            canvas { height: 65vh !important; }

            #company-logo {
                top: 15px; right: 15px; bottom: auto; left: auto;
                width: 38px; opacity: 0.9; z-index: 100;
            }

            #ui {
                top: 65vh; left: 0; width: 60%; height: 35vh;
                background: #000; border-right: 1px solid #333; border-top: 1px solid #333;
                padding: 12px 10px 40px 10px; border-radius: 0; overflow-y: auto; overflow-x: hidden;
                touch-action: pan-y; /* ç¢ºä¿èƒŒæ™¯æ²å‹•é †æš¢ */
            }

            #preview-box {
                top: 65vh; right: 0; left: auto; 
                width: 40%; height: 35vh;
                background: #050505; border: none; border-top: 1px solid #333; border-left: 1px solid #333;
                padding: 0; justify-content: flex-start; align-items: stretch; border-radius: 0;
            }
            .type-label { font-size: 1.1em; padding: 6px; margin-bottom: 0; background: #111; }
            #preview-container { 
                flex: 1; display: flex; flex-direction: column; 
                justify-content: center; align-items: center; padding: 5px;
            }
            #pCanvas { width: 95% !important; height: auto !important; max-width: 110px; }

            /* é—œéµï¼šæ‰‹æ©Ÿç‰ˆç¦ç”¨æ»‘æ¡¿çš„åŸç”Ÿé»æ“Šè·³è½‰ï¼Œç”± JS æ‰‹å‹•æ§åˆ¶æ»‘å‹• */
            input[type=range] { pointer-events: none; }
            .param-group { touch-action: pan-y; }
        }
    </style>
</head>
<body>

<div class="main-title">åœ“éŒæ›²ç·šæ¨¡å‹</div>

<div id="ui">
    <div class="section-title">æ•¸æ“šè¨­å®š</div>

    <div class="param-group">
        <div class="label-row"><label>æ¯ç·šå¤¾è§’ (Î±):</label><input type="number" id="alphaN" value="30"></div>
        <input type="range" id="alphaS" min="5" max="85" step="0.1" value="30">
    </div>

    <div class="param-group">
        <div class="label-row"><label>å¹³é¢å¤¾è§’ (Î²):</label><input type="number" id="betaN" value="90"></div>
        <input type="range" id="betaS" min="0" max="180" step="0.1" value="90">
    </div>

    <div class="param-group">
        <div class="label-row"><label>å‚ç›´ä½ç§» (Y):</label><input type="number" id="yN" value="2.0"></div>
        <input type="range" id="yS" min="-10" max="10" step="0.1" value="2.0">
    </div>

    <div class="param-group">
        <div class="label-row"><label>æ°´å¹³ä½ç§» (X):</label><input type="number" id="xN" value="0.0"></div>
        <input type="range" id="xS" min="-10" max="10" step="0.1" value="0.0">
    </div>

    <div class="param-group">
        <div class="label-row"><label>å‰å¾Œä½ç§» (Z):</label><input type="number" id="zN" value="0.0"></div>
        <input type="range" id="zS" min="-10" max="10" step="0.1" value="0.0">
    </div>
</div>

<img id="company-logo" src="company-logo.png" alt="Company Logo">

<div id="preview-box">
    <div class="type-label" id="curveType">åœ“</div>
    <div id="preview-container">
        <div style="font-size: 10px; margin-bottom:4px; text-align:center; color:#999;">æˆªé¢åœ–å½¢</div>
        <canvas id="pCanvas" width="220" height="220"></canvas>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    // --- 3D ç’°å¢ƒ ---
    const scene = new THREE.Scene();
    const isMobile = window.innerWidth <= 768;
    const aspect = isMobile ? (window.innerWidth / (window.innerHeight * 0.65)) : ((window.innerWidth - 210) / window.innerHeight);
    const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.GridHelper(30, 60, 0x222222, 0x222222));
    let topCone, bottomCone;
    const coneMat = new THREE.MeshPhongMaterial({ color: 0x3498db, transparent: true, opacity: 0.35, side: THREE.DoubleSide });
    const planeGroup = new THREE.Group();
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(35,35), new THREE.MeshPhongMaterial({color:0xff4757, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
    plane.rotation.x = Math.PI/2;
    planeGroup.add(plane);
    scene.add(planeGroup);
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);

    // åˆå§‹è¦–è·å›æ­¸ç‚º 32ï¼Œé€™æ˜¯å¤§æ¨¹è€å¸«èªç‚ºæœ€å”èª¿çš„å¤§å°
    if (isMobile) { camera.position.set(32, 22, 32); } 
    else { camera.position.set(25, 18, 25); }
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);

    const params = ['alpha', 'beta', 'x', 'y', 'z'];
    
    function update() {
        const a = parseFloat(document.getElementById('alphaN').value);
        const b = parseFloat(document.getElementById('betaN').value);
        const px = parseFloat(document.getElementById('xN').value);
        const py = parseFloat(document.getElementById('yN').value);
        const pz = parseFloat(document.getElementById('zN').value);
        if (topCone) { scene.remove(topCone); scene.remove(bottomCone); }
        const radA = a * Math.PI/180;
        const h = 12; 
        const geom = new THREE.ConeGeometry(h*Math.tan(radA), h, 128, 1, true);
        geom.translate(0, -h/2, 0); 
        topCone = new THREE.Mesh(geom, coneMat);
        bottomCone = new THREE.Mesh(geom, coneMat); bottomCone.rotation.x = Math.PI;
        scene.add(topCone, bottomCone);
        const radB_rot = (90 - b) * (Math.PI/180);
        planeGroup.rotation.x = radB_rot;
        planeGroup.position.set(px, py, pz);
        const eb = b > 90 ? 180 - b : b;
        const nx = 0, ny = Math.cos(radB_rot), nz = Math.sin(radB_rot);
        const dist = Math.abs(px*0 + py*ny + pz*nz); 
        const passV = dist < 0.08;
        const tol = 0.1;
        let type = "";
        if (passV) {
            if (Math.abs(eb - a) < tol) type = "ä¸€æ¢ç›´ç·š";
            else if (eb > a) type = "ä¸€å€‹é»";
            else type = "å…©ç›¸äº¤ç›´ç·š";
        } else {
            if (Math.abs(eb - 90) < tol) type = "åœ“";
            else if (eb > a) type = "æ©¢åœ“";
            else if (Math.abs(eb - a) < tol) type = "æ‹‹ç‰©ç·š";
            else type = "é›™æ›²ç·š";
        }
        document.getElementById('curveType').innerText = type;
        draw2D(type, a, eb, dist);
    }

    function draw2D(type, aDeg, bDeg, dist) {
        const canvas = document.getElementById('pCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,220,220);
        ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 3.5; ctx.fillStyle = "#00ffcc";
        const mid = 110, scale = 25;
        const alpha = aDeg * Math.PI/180, beta = bDeg * Math.PI/180;
        if (type === "åœ“") {
            ctx.beginPath(); ctx.arc(mid, mid, Math.abs(dist * Math.tan(alpha) * scale), 0, Math.PI*2); ctx.stroke();
        } else if (type === "ä¸€å€‹é»") {
            ctx.beginPath(); ctx.arc(mid, mid, 6, 0, Math.PI*2); ctx.fill();
        } else if (type === "ä¸€æ¢ç›´ç·š") {
            ctx.beginPath(); ctx.moveTo(mid, 20); ctx.lineTo(mid, 200); ctx.stroke();
        } else if (type === "å…©ç›¸äº¤ç›´ç·š") {
            ctx.beginPath(); const s = Math.tan(alpha);
            ctx.moveTo(mid-100, mid-100*s); ctx.lineTo(mid+100, mid+100*s);
            ctx.moveTo(mid+100, mid-100*s); ctx.lineTo(mid-100, mid+100*s);
            ctx.stroke();
        } else if (type === "æ©¢åœ“") {
            ctx.beginPath();
            const e = Math.cos(beta) / Math.cos(alpha);
            const a = Math.abs(dist * Math.sin(alpha)*Math.cos(alpha) / (Math.pow(Math.sin(beta),2) - Math.pow(Math.sin(alpha),2)));
            const b = a * Math.sqrt(Math.abs(1 - e*e));
            ctx.ellipse(mid, mid, a*scale, b*scale, 0, 0, Math.PI*2); ctx.stroke();
        } else if (type === "æ‹‹ç‰©ç·š") {
            ctx.beginPath(); const p = Math.abs(dist * Math.sin(alpha));
            for(let y = -95; y <= 95; y++) {
                const x = (y*y) / (4 * p * scale || 1);
                if(y === -95) ctx.moveTo(mid + x, mid + y); else ctx.lineTo(mid + x, mid + y);
            }
            ctx.stroke();
        } else if (type === "é›™æ›²ç·š") {
            const drawBranch = (s) => {
                ctx.beginPath(); let first = true;
                const e = Math.cos(beta) / Math.cos(alpha);
                const a = Math.abs(dist * Math.cos(alpha)*Math.sin(alpha) / (Math.pow(Math.sin(alpha),2) - Math.pow(Math.sin(beta),2)));
                const b = a * Math.sqrt(Math.abs(e*e - 1));
                for(let y = -95; y <= 95; y++) {
                    const x = a * Math.sqrt(1 + Math.pow(y / (b * scale || 1), 2));
                    if(first) { ctx.moveTo(mid + s * x * scale, mid + y); first = false; }
                    else { ctx.lineTo(mid + s * x * scale, mid + y); }
                }
                ctx.stroke();
            };
            drawBranch(1); drawBranch(-1);
        }
    }

    // --- [æ ¸å¿ƒï¼šå¾¹åº•ç¦æ­¢æ‰‹æ©Ÿé»æ“Šè·³è½‰ï¼Œåƒ…é™å·¦å³æ‹–æ‹‰] ---
    params.forEach(p => {
        const s = document.getElementById(p + 'S'), n = document.getElementById(p + 'N');
        const paramGroup = s.parentElement; // param-group

        let startX, startY, initVal, isSliding = false;

        // æ‰‹æ©Ÿç‰ˆå°ˆå±¬äº‹ä»¶æ•æ‰
        if (isMobile) {
            paramGroup.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                initVal = parseFloat(s.value);
                isSliding = false;
            }, { passive: true });

            paramGroup.addEventListener('touchmove', (e) => {
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;

                // ç‰©ç†åˆ¤å®šï¼šä½ç§»å¤§æ–¼ 10 ä¸”æ°´å¹³å¤§æ–¼å‚ç›´
                if (!isSliding && Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
                    isSliding = true;
                }

                if (isSliding) {
                    if (e.cancelable) e.preventDefault(); // é–å®šæ²è»¸

                    const rect = s.getBoundingClientRect();
                    // æ ¹æ“šä½ç§»æ¯”ä¾‹è¨ˆç®—æ–°æ•¸å€¼
                    const deltaVal = (dx / rect.width) * (parseFloat(s.max) - parseFloat(s.min));
                    let newVal = initVal + deltaVal;
                    newVal = Math.max(parseFloat(s.min), Math.min(parseFloat(s.max), newVal));
                    
                    s.value = newVal;
                    n.value = Math.round(newVal * 10) / 10;
                    update();
                }
            }, { passive: false });
        }

        // é›»è…¦ç‰ˆç¶­æŒåŸç”Ÿ
        s.addEventListener('input', () => { if (!isMobile) { n.value = s.value; update(); } });
        n.addEventListener('change', () => { s.value = n.value; update(); });
    });

    window.addEventListener('resize', () => {
        const isMob = window.innerWidth <= 768;
        const newAspect = isMob ? (window.innerWidth / (window.innerHeight * 0.65)) : ((window.innerWidth - 210) / window.innerHeight);
        camera.aspect = newAspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    update(); animate();
</script>
</body>
</html>
